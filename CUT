
    '''
    def get_build(self, target, name=None):
        with self._builds_mtx:
            builds = os.listdir(self.BUILDS)
            def keep(x):
                if name is None:
                    return x.startswith(target + ':')
                else:
                    return x == target + ':' + name
            builds = [b for b in builds if keep(b)]
            def key(x):
                st = os.stat(os.path.join(self.BUILDS, x))
                return st.st_mtime
            builds = sorted(builds, key=key, reverse=True)
            if builds:
                return builds[0]
            else:
                return None

    def dispatch_status(self, sock, cmd):
        parser = minion.cmd.status(MinionThrowingArgumentParser())
        args = parser.parse_args(cmd)
        if args.name is not None:
            display_name = '%s:%s' % (args.target, args.name)
        else:
            display_name = '%s' % args.target
        build = self.get_build(args.target, args.name)
        reporter = args.report.replace('-', '_')
        reporter = getattr(self, 'report_' + reporter, None)
        if reporter is None:
            return {'status': 'failure', 'output': 'no such reporter'}
        if build is None:
            return {'status': 'failure', 'output': 'no such build as %s' % display_name}
        build = open(os.path.join(self.BUILDS, build)).read()
        report = json.loads(build)
        return {'status': 'success', 'output': reporter(report)}
        '''
    def report_one_bit(self, report):
        success = True
        for x in report['reports']:
            if not x['success']:
                success = False
        if success:
            return 'success'
        else:
            return 'failure'

    def report_short(self, report):
        r = ''
        r += 'Minionfile: %s\n' % report['minionfile']
        r += 'Sources: %s\n' % report['sources']
        r += '\n'
        for idx, x in enumerate(report['reports']):
            if x['success']:
                r += x['name'] + ': success'
                if x['released']:
                    r += ' [released]'
                elif x['cached']:
                    r += ' [cached]'
                r += '\n'
            else:
                r += '%s: failure\n' % x['name']
        return r

    def report_long(self, report):
        r = ''
        r += 'Minionfile: %s\n' % report['minionfile']
        r += 'Sources: %s\n' % report['sources']
        r += '\n'
        parsed = self.parse(self.blobs.path(report['minionfile']))
        for idx, x in enumerate(report['reports']):
            if x['success']:
                r += x['name'] + ': success'
                if x['released']:
                    r += ' [released]'
                elif x['cached']:
                    r += ' [cached]'
                r += '\n'
            elif '-' in (x['inputs'], x['outputs']) and not x['cached']:
                r += '%s: aborted\n' % x['name']
            else:
                r += '%s: failure\n' % x['name']
                proc = None
                for p in parsed:
                    if str(p.name) == x['name']:
                        proc = p
                if proc is None:
                    raise MinionError('report corrupt')
                success, log, artifacts = self.read_output(proc, x['outputs'])
                r += log.decode('utf8')
                break
        return r

    def report_full(self, report):
        r = ''
        r += 'Minionfile: %s\n' % report['minionfile']
        r += 'Sources: %s\n' % report['sources']
        r += '\n'
        parsed = self.parse(self.blobs.path(report['minionfile']))
        for idx, x in enumerate(report['reports']):
            print_log = False
            if x['success']:
                r += x['name'] + ': success'
                if x['released']:
                    r += ' [released]'
                elif x['cached']:
                    r += ' [cached]'
                r += '\n'
                print_log = True
            elif '-' in (x['inputs'], x['outputs']) and not x['cached']:
                r += '%s: aborted\n' % x['name']
            else:
                r += '%s: failure\n' % x['name']
                print_log = True
            if print_log:
                proc = None
                for p in parsed:
                    if str(p.name) == x['name']:
                        proc = p
                if proc is None:
                    raise MinionError('report corrupt')
                success, log, artifacts = self.read_output(proc, x['outputs'])
                r += log.decode('utf8')
                r += '\n' + '=' * 80 + '\n\n'
        return r

    def report_failed(self, report):
        r = ''
        for idx, x in enumerate(report['reports']):
            w
            if not x['success']:
                r += '%s\n' % x['name']
        return r

    def report_docker_images(self, report):
        r = ''
        for x in report['reports']:
            if x['inputs'] == '-':
                continue
            stub = self.blobs.read(x['inputs']).decode('utf8', 'ignore')
            match = re.search('^Image: (\w+)$', stub, re.MULTILINE)
            if match is None:
                continue
            r += match.group(1) + '\n'
        return r
